import Color = require('color');
import { ShareTarget, WebManifestIcon, WebManifestJson } from './types/WebManifest';
import { ShortcutInfo } from './ShortcutInfo';
import { AppsFlyerConfig } from './features/AppsFlyerFeature';
import { LocationDelegationConfig } from './features/LocationDelegationFeature';
import { PlayBillingConfig } from './features/PlayBillingFeature';
import { FirstRunFlagConfig } from './features/FirstRunFlagFeature';
import { ArCoreConfig } from './features/ArCoreFeature';
declare const DISPLAY_MODE_VALUES: string[];
export declare type DisplayMode = typeof DISPLAY_MODE_VALUES[number];
export declare const DisplayModes: DisplayMode[];
export declare function asDisplayMode(input: string): DisplayMode | null;
declare const ORIENTATION_VALUES: string[];
export declare type Orientation = typeof ORIENTATION_VALUES[number];
export declare const Orientations: Orientation[];
export declare function asOrientation(input?: string): Orientation | null;
export declare type FallbackType = 'customtabs' | 'webview';
declare type Features = {
    appsFlyer?: AppsFlyerConfig;
    locationDelegation?: LocationDelegationConfig;
    playBilling?: PlayBillingConfig;
    firstRunFlag?: FirstRunFlagConfig;
    arCore?: ArCoreConfig;
};
declare type alphaDependencies = {
    enabled: boolean;
};
/**
 * A Manifest used to generate the TWA Project
 *
 * applicationId: '<%= packageId %>',
 * hostName: '<%= host %>', // The domain being opened in the TWA.
 * launchUrl: '<%= startUrl %>', // The start path for the TWA. Must be relative to the domain.
 * name: '<%= name %>', // The name shown on the Android Launcher.
 * display: '<%= display %>', // The display mode for the TWA.
 * themeColor: '<%= themeColor %>', // The color used for the status bar.
 * navigationColor: '<%= themeColor %>', // The color used for the navigation bar.
 * navigationColorDark: '<%= navigationColorDark %>', // The color used for the dark navbar.
 * navigationDividerColor: '<%= navigationDividerColor %>', // The color used for the
 * navbar divider.
 * navigationDividerColorDark: '<%= navigationDividerColorDark %>', // The color used for the dark
 * navbar divider.
 * backgroundColor: '<%= backgroundColor %>', // The color used for the splash screen background.
 * enableNotifications: false, // Set to true to enable notification delegation.
 * enableSiteSettingsShortcut: true, // Set to false to disable the shortcut into site settings.
 * // Add shortcuts for your app here. Every shortcut must include the following fields:
 * // - name: String that will show up in the shortcut.
 * // - shortName: Shorter string used if |name| is too long.
 * // - url: Absolute path of the URL to launch the app with (e.g '/create').
 * // - chosenIconUrl: Name of the resource in the drawable folder to use as an icon.
 * shortcuts: [
 *      // Insert shortcuts here, for example:
 *      // { name: 'Open SVG', shortName: 'Open', url: '/open', chosenIconUrl: 'https://example.com/example.svg' }
 *  ],
 * // The duration of fade out animation in milliseconds to be played when removing splash screen.
 * splashScreenFadeOutDuration: 300
 * isChromeOSOnly: false, // Setting to true will enable a feature that prevents non-ChromeOS devices
 *  from installing the app.
 * isMetaQuest: false, // Setting to true will generate the build compatible with Meta Quest devices.
 * serviceAccountJsonFile: '<%= serviceAccountJsonFile %>', // The service account used to communicate with
 *  Google Play.
 *
 */
export declare class TwaManifest {
    packageId: string;
    host: string;
    name: string;
    launcherName: string;
    display: DisplayMode;
    themeColor: Color;
    navigationColor: Color;
    navigationColorDark: Color;
    navigationDividerColor: Color;
    navigationDividerColorDark: Color;
    backgroundColor: Color;
    enableNotifications: boolean;
    startUrl: string;
    iconUrl: string | undefined;
    maskableIconUrl: string | undefined;
    monochromeIconUrl: string | undefined;
    splashScreenFadeOutDuration: number;
    signingKey: SigningKeyInfo;
    appVersionCode: number;
    appVersionName: string;
    shortcuts: ShortcutInfo[];
    generatorApp: string;
    webManifestUrl?: URL;
    fallbackType: FallbackType;
    features: Features;
    alphaDependencies: alphaDependencies;
    enableSiteSettingsShortcut: boolean;
    isChromeOSOnly: boolean;
    isMetaQuest: boolean;
    fullScopeUrl?: URL;
    minSdkVersion: number;
    shareTarget?: ShareTarget;
    orientation: Orientation;
    fingerprints: Fingerprint[];
    serviceAccountJsonFile: string | undefined;
    additionalTrustedOrigins: string[];
    retainedBundles: number[];
    private static log;
    constructor(data: TwaManifestJson);
    /**
     * Turns an TwaManifest into a TwaManifestJson.
     *
     * @returns {TwaManifestJson}
     */
    toJson(): TwaManifestJson;
    /**
     * Saves the TWA Manifest to the file-system.
     *
     * @param {String} filename the location where the TWA Manifest will be saved.
     */
    saveToFile(filename: string): Promise<void>;
    /**
     * Validates if the Manifest has all the fields needed to generate a TWA project and if the
     * values for those fields are valid.
     *
     * @returns {string | null} the error, if any field has an error or null if all fields are valid.
     */
    validate(): string | null;
    generateShortcuts(): string;
    /**
     * Creates a new TwaManifest, using the URL for the Manifest as a base URL and uses the content
     * of the Web Manifest to generate the fields for the TWA Manifest.
     *
     * @param {URL} webManifestUrl the URL where the webmanifest is available.
     * @param {WebManifest} webManifest the Web Manifest, used as a base for the TWA Manifest.
     * @returns {TwaManifest}
     */
    static fromWebManifestJson(webManifestUrl: URL, webManifest: WebManifestJson): TwaManifest;
    private static verifyShareTarget;
    /**
     * Fetches a Web Manifest from the url and uses it as a base for the TWA Manifest.
     *
     * @param {String} url the URL where the webmanifest is available
     * @returns {TwaManifest}
     */
    static fromWebManifest(url: string): Promise<TwaManifest>;
    /**
     * Loads a TWA Manifest from the file system.
     *
     * @param {String} fileName the location of the TWA Manifest file
     */
    static fromFile(fileName: string): Promise<TwaManifest>;
    /**
     * Given a field name, returns the new value of the field.
     *
     * @param {string} fieldName the name of the given field.
     * @param {string[]} fieldsToIgnore the fields which needs to be ignored.
     * @param {T} oldValue the old value of the field.
     * @param {T} newValue the new value of the field.
     * @returns {T}
     */
    static getNewFieldValue<T>(fieldName: string, fieldsToIgnore: string[], oldValue: T, newValue: T): T;
    /**
     * Gets the shortcuts from the web manifest.
     *
     * @param {URL} webManifestUrl the URL where the webManifest is available.
     * @param {WebManifest} webManifest the Web Manifest.
     * @returns {ShortcutInfo[]}
     */
    static getShortcuts(webManifestUrl: URL, webManifest: WebManifestJson): ShortcutInfo[];
    /**
     * @param {string[]} fieldsToIgnore the fields which needs to be ignored.
     * @param {string} fieldName the name of the given field.
     * @param {string} oldUrl the url of the old twaManifest.
     * @param {WebManifestIcon[]} icons the list of icons from the web manifest.
     * @param {string} iconType the type of the requested icon.
     * @param {number} iconSize the size of the requested icon.
     * @param {URL} webManifestUrl the URL where the webManifest is available.
     * @returns {string | undefined} the new icon url.
     */
    static getNewIconUrl(fieldsToIgnore: string[], fieldName: string, oldUrl: string, icons: WebManifestIcon[], iconType: string, iconSize: number, webManifestUrl: URL): string | undefined;
    /**
     * Merges the Twa Manifest with the web manifest. Ignores the specified fields.
     *
     * @param {string[]} fieldsToIgnore the fields which needs to be ignored.
     * @param {URL} webManifestUrl the URL where the webManifest is available.
     * @param {WebManifest} webManifest the Web Manifest, used as a base for the update of
     *    the TWA Manifest.
     * @param {TwaManifest} oldTwaManifest current Twa Manifest.
     * @returns {Promise<TwaManifest>} the new and merged Twa manifest.
     */
    static merge(fieldsToIgnore: string[], webManifestUrl: URL, webManifest: WebManifestJson, oldTwaManifest: TwaManifest): Promise<TwaManifest>;
}
/**
 * A JSON representation of the TWA Manifest. Used when loading and saving the Manifest
 */
export interface TwaManifestJson {
    packageId: string;
    host: string;
    name: string;
    launcherName?: string;
    display?: string;
    themeColor: string;
    navigationColor: string;
    navigationColorDark?: string;
    navigationDividerColor?: string;
    navigationDividerColorDark?: string;
    backgroundColor: string;
    enableNotifications: boolean;
    startUrl: string;
    iconUrl?: string;
    maskableIconUrl?: string;
    monochromeIconUrl?: string;
    splashScreenFadeOutDuration: number;
    signingKey: SigningKeyInfo;
    appVersionCode?: number;
    appVersion: string;
    shortcuts?: ShortcutInfo[];
    generatorApp?: string;
    webManifestUrl?: string;
    fallbackType?: FallbackType;
    features?: {
        appsFlyer?: AppsFlyerConfig;
        locationDelegation?: LocationDelegationConfig;
        playBilling?: PlayBillingConfig;
        firstRunFlag?: FirstRunFlagConfig;
        arCore?: ArCoreConfig;
    };
    alphaDependencies?: {
        enabled: boolean;
    };
    enableSiteSettingsShortcut?: boolean;
    isChromeOSOnly?: boolean;
    isMetaQuest?: boolean;
    fullScopeUrl?: string;
    minSdkVersion?: number;
    shareTarget?: ShareTarget;
    orientation?: Orientation;
    fingerprints?: Fingerprint[];
    serviceAccountJsonFile?: string;
    additionalTrustedOrigins?: string[];
    retainedBundles?: number[];
}
export interface SigningKeyInfo {
    path: string;
    alias: string;
}
export declare type Fingerprint = {
    name?: string;
    value: string;
};
export {};
