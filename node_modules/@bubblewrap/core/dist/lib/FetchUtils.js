"use strict";
/*
 * Copyright 2021 Google Inc. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchUtils = void 0;
const fs = require("fs");
const fetch_h2_1 = require("fetch-h2");
const node_fetch_1 = require("node-fetch");
const DEFAULT_FETCH_ENGINE = 'fetch-h2';
const userAgent = 'Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/81.0';
const fetchh2Ctx = fetch_h2_1.context({ userAgent: userAgent, overwriteUserAgent: true });
const fetchh2 = fetchh2Ctx.fetch;
class FetchUtils {
    constructor() {
        this.fetchEngine = DEFAULT_FETCH_ENGINE;
    }
    setFetchEngine(newFetchEngine) {
        this.fetchEngine = newFetchEngine;
    }
    async fetch(input) {
        if (this.fetchEngine == 'node-fetch') {
            return await node_fetch_1.default(input, { redirect: 'follow', headers: { 'User-Agent': userAgent } });
        }
        else {
            return await fetchh2(input, { redirect: 'follow' });
        }
    }
    /**
     * Downloads a file from `url` and saves it to `path`. If a `progressCallback` function is passed, it
     * will be invoked for every chunk received. If the value of `total` parameter is -1, it means we
     * were unable to determine to total file size before starting the download.
     */
    async downloadFile(url, path, progressCallback) {
        let result;
        let readableStream;
        if (this.fetchEngine === 'node-fetch') {
            result = await node_fetch_1.default(url);
            readableStream = result.body;
        }
        else {
            result = await fetchh2(url, { redirect: 'follow' });
            readableStream = await result.readable();
        }
        // Try to determine the file size via the `Content-Length` header. This may not be available
        // for all cases.
        const contentLength = result.headers.get('content-length');
        const fileSize = contentLength ? parseInt(contentLength) : -1;
        const fileStream = fs.createWriteStream(path);
        let received = 0;
        await new Promise((resolve, reject) => {
            readableStream.pipe(fileStream);
            // Even though we're piping the chunks, we intercept them to check for the download progress.
            if (progressCallback) {
                readableStream.on('data', (chunk) => {
                    received = received + chunk.length;
                    progressCallback(received, fileSize);
                });
            }
            readableStream.on('error', (err) => {
                reject(err);
            });
            fileStream.on('finish', () => {
                resolve();
            });
        });
    }
}
const fetchUtils = new FetchUtils();
exports.fetchUtils = fetchUtils;
