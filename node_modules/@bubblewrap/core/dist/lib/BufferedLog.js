"use strict";
/*
 * Copyright 2020 Google Inc. All Rights Reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferedLog = void 0;
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
})(LogLevel || (LogLevel = {}));
/** Data class to store level and message of pending */
class PendingLog {
    constructor(level, message) {
        this.level = level;
        this.message = message;
    }
}
/**
 * A Log that wraps another Log, saving up all the log calls to be applied when flush is called.
 *
 * It doesn't currently support arguments to the log messages.
 */
class BufferedLog {
    constructor(innerLog) {
        this.innerLog = innerLog;
        this.pendingLogs = [];
        // The "no-invalid-this" triggers incorrectly on the below code, see:
        // https://github.com/eslint/eslint/issues/13894
        // https://github.com/typescript-eslint/typescript-eslint/issues/2840
        /* eslint-disable no-invalid-this */
        this.debug = this.addLogFunction(LogLevel.Debug);
        this.info = this.addLogFunction(LogLevel.Info);
        this.warn = this.addLogFunction(LogLevel.Warn);
        this.error = this.addLogFunction(LogLevel.Error);
    }
    /* eslint-enable no-invalid-this */
    /** Creates a function that adds a log at the given level. */
    addLogFunction(level) {
        return (message) => {
            this.pendingLogs.push(new PendingLog(level, message));
        };
    }
    setVerbose(verbose) {
        this.innerLog.setVerbose(verbose);
    }
    /** Flushes all recorded logs to the underlying object. */
    flush() {
        this.pendingLogs.forEach((pendingLog) => {
            const message = pendingLog.message;
            switch (pendingLog.level) {
                case LogLevel.Debug:
                    this.innerLog.debug(message);
                    break;
                case LogLevel.Info:
                    this.innerLog.info(message);
                    break;
                case LogLevel.Warn:
                    this.innerLog.warn(message);
                    break;
                case LogLevel.Error:
                    this.innerLog.error(message);
                    break;
            }
        });
        this.pendingLogs = [];
    }
}
exports.BufferedLog = BufferedLog;
