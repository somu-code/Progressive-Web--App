"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deferSet = exports.OrderedAsynchrony = exports.funnel = exports.wrapFunction = exports.rethrow = exports.specific = exports.Try = exports.deferInspectable = exports.inspect = exports.reflect = exports.defer = exports.retry = exports.once = exports.some = exports.eachImpl = exports.each = exports.reduce = exports.map = exports.filter = exports.props = exports.tap = exports.Finally = exports.finallyDelay = exports.delayChain = exports.delay = void 0;
var throat_1 = require("throat");
exports.default = {
    Finally: Finally,
    Try: Try,
    defer: defer,
    deferSet: deferSet,
    delay: delay,
    delayChain: delayChain,
    each: each,
    filter: filter,
    finally: Finally,
    finallyDelay: finallyDelay,
    funnel: funnel,
    inspect: inspect,
    map: map,
    once: once,
    props: props,
    reduce: reduce,
    rethrow: rethrow,
    retry: retry,
    some: some,
    specific: specific,
    tap: tap,
    wrapFunction: wrapFunction,
};
function toReadonlyArray(arr) {
    /* istanbul ignore else */
    if (typeof arr.map === "function")
        return arr;
    else
        return Array.from(arr);
}
function delay(milliseconds, t) {
    return new Promise(function (resolve) {
        setTimeout(function () { return resolve(t); }, milliseconds);
    });
}
exports.delay = delay;
function delayChain(milliseconds) {
    return tap(function () { return delay(milliseconds); });
}
exports.delayChain = delayChain;
function finallyDelay(milliseconds) {
    return Finally(function () { return delay(milliseconds); });
}
exports.finallyDelay = finallyDelay;
function Finally(fn) {
    function _then(t) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fn()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, t];
                }
            });
        });
    }
    function _catch(err) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fn()];
                    case 1:
                        _a.sent();
                        throw err;
                }
            });
        });
    }
    return [_then, _catch];
}
exports.Finally = Finally;
function tap(fn) {
    var _this = this;
    return function (t) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fn(t)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, t];
            }
        });
    }); };
}
exports.tap = tap;
function props(obj) {
    var e_1, _a;
    var ret = {};
    var awaiters = [];
    var _loop_1 = function (prop) {
        awaiters.push(Promise.resolve(obj[prop])
            .then(function (val) { ret[prop] = val; }));
    };
    try {
        for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var prop = _c.value;
            _loop_1(prop);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Promise.all(awaiters).then(function () { return ret; });
}
exports.props = props;
var defaultFilterMapOptions = { concurrency: Infinity };
function filter(arr, opts, filterFn) {
    if (Array.isArray(arr)) {
        if (typeof opts === "function") {
            filterFn = opts;
            opts = defaultFilterMapOptions;
        }
        var intermediate = filter(opts, filterFn);
        return intermediate(arr);
    }
    filterFn = typeof arr === "function" ? arr : opts;
    opts =
        typeof arr === "function"
            ? defaultFilterMapOptions
            : arr;
    var wrappedFilterFn = function (val, index, arr) {
        return Promise.resolve(filterFn(val, index, arr))
            .then(function (ok) { return ({ ok: ok, val: val }); });
    };
    return function (t) {
        return map(opts, wrappedFilterFn)(t)
            .then(function (values) {
            return values
                .filter(function (_a) {
                var ok = _a.ok;
                return ok;
            })
                .map(function (_a) {
                var val = _a.val;
                return val;
            });
        });
    };
}
exports.filter = filter;
function map(arr, opts, mapFn) {
    if (Array.isArray(arr)) {
        if (typeof opts === "function") {
            mapFn = opts;
            opts = defaultFilterMapOptions;
        }
        return map(opts, mapFn)(arr);
    }
    mapFn = typeof arr === "function" ? arr : opts;
    opts =
        typeof arr === "function"
            ? defaultFilterMapOptions
            : arr;
    var _a = opts.concurrency, concurrency = _a === void 0 ? Infinity : _a;
    var promiseMapFn = function (t, index, arr) {
        return Promise.resolve(mapFn(t, index, arr));
    };
    var throated = throat_1.default(concurrency);
    return function (t) {
        return Promise.resolve(t)
            .then(function (values) {
            return toReadonlyArray(values).map(function (val, index, arr) {
                return throated(function () { return Promise.resolve(val); })
                    .then(function (val) {
                    return throated(function () { return promiseMapFn(val, index, arr); });
                });
            });
        })
            .then(function (values) { return Promise.all(values); });
    };
}
exports.map = map;
function reduce(input, reducer, initialValue) {
    var _this = this;
    if (typeof input === "function") {
        initialValue = reducer;
        var _reducer_1 = input;
        return function (input) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, reduceImpl(input, _reducer_1, initialValue)];
            });
        }); };
    }
    return reduceImpl(input, reducer, initialValue);
}
exports.reduce = reduce;
function reduceImpl(input, reducer, initialValue) {
    return __awaiter(this, void 0, void 0, function () {
        var _input, _a, _b, _initialValue, usingInitialValue, length, index, accumulator, _c, _d, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    _b = (_a = Array).from;
                    return [4 /*yield*/, input];
                case 1:
                    _input = _b.apply(_a, [_f.sent()]);
                    return [4 /*yield*/, initialValue];
                case 2:
                    _initialValue = _f.sent();
                    if (_input.length === 0)
                        return [2 /*return*/, _initialValue];
                    usingInitialValue = typeof _initialValue !== "undefined";
                    length = _input.length;
                    index = usingInitialValue ? 0 : 1;
                    if (!usingInitialValue) return [3 /*break*/, 3];
                    _c = _initialValue;
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, _input.shift()];
                case 4:
                    _c = _f.sent();
                    _f.label = 5;
                case 5:
                    accumulator = _c;
                    _f.label = 6;
                case 6:
                    if (!(_input.length > 0)) return [3 /*break*/, 9];
                    _d = reducer;
                    _e = [accumulator];
                    return [4 /*yield*/, _input.shift()];
                case 7: return [4 /*yield*/, _d.apply(void 0, _e.concat([_f.sent(), index++, length]))];
                case 8:
                    accumulator = _f.sent();
                    return [3 /*break*/, 6];
                case 9: return [2 /*return*/, accumulator];
            }
        });
    });
}
function each(arr, eachFn) {
    if (Array.isArray(arr))
        return eachImpl(eachFn)(arr);
    return eachImpl(arr);
}
exports.each = each;
function eachImpl(eachFn) {
    var _this = this;
    return function (arr) { return __awaiter(_this, void 0, void 0, function () {
        function iterator(t, index) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, eachFn(t, index, length)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, t];
                    }
                });
            });
        }
        var length;
        return __generator(this, function (_a) {
            length = arr.length;
            return [2 /*return*/, map(arr, { concurrency: 1 }, iterator)];
        });
    }); };
}
exports.eachImpl = eachImpl;
function some(list, fn) {
    if (typeof list === "function") {
        fn = list;
        return function (list) {
            return someImpl(list, fn);
        };
    }
    return someImpl(list, fn);
}
exports.some = some;
function someImpl(list, fn) {
    return __awaiter(this, void 0, void 0, function () {
        var _list, _a, _list_1, _list_1_1, val, ret, _b, e_2_1;
        var e_2, _c;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    _a = toReadonlyArray;
                    return [4 /*yield*/, list];
                case 1:
                    _list = _a.apply(void 0, [_d.sent()]);
                    _d.label = 2;
                case 2:
                    _d.trys.push([2, 8, 9, 10]);
                    _list_1 = __values(_list), _list_1_1 = _list_1.next();
                    _d.label = 3;
                case 3:
                    if (!!_list_1_1.done) return [3 /*break*/, 7];
                    val = _list_1_1.value;
                    _b = fn;
                    return [4 /*yield*/, val];
                case 4: return [4 /*yield*/, _b.apply(void 0, [_d.sent()])];
                case 5:
                    ret = _d.sent();
                    if (ret)
                        return [2 /*return*/, ret];
                    _d.label = 6;
                case 6:
                    _list_1_1 = _list_1.next();
                    return [3 /*break*/, 3];
                case 7: return [3 /*break*/, 10];
                case 8:
                    e_2_1 = _d.sent();
                    e_2 = { error: e_2_1 };
                    return [3 /*break*/, 10];
                case 9:
                    try {
                        if (_list_1_1 && !_list_1_1.done && (_c = _list_1.return)) _c.call(_list_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                    return [7 /*endfinally*/];
                case 10: return [2 /*return*/, false];
            }
        });
    });
}
function once(fn) {
    if (fn) {
        var _once_1 = onceDynamic();
        return (function (t) { return _once_1(fn, t); });
    }
    else
        return onceDynamic();
}
exports.once = once;
function onceDynamic() {
    var state = new WeakMap();
    var ensureState = function (fn) {
        if (!state.has(fn))
            state.set(fn, { hasRun: false });
    };
    return (function (fn, t) {
        ensureState(fn);
        var stateObject = state.get(fn);
        if (stateObject.hasRun) {
            if (stateObject.deferred)
                return stateObject.deferred.promise;
            return stateObject.returnValue;
        }
        stateObject.hasRun = true;
        var ret = fn(t);
        var pret = ret;
        if (pret !== undefined && pret && typeof pret.then === "function") {
            stateObject.deferred = defer(void 0);
            return pret
                .then(stateObject.deferred.resolve, rethrow(stateObject.deferred.reject))
                .then(function () {
                return stateObject.deferred.promise;
            });
        }
        stateObject.returnValue = ret;
        return ret;
    });
}
function retry(times, fn, retryable) {
    if (retryable === void 0) { retryable = function () { return true; }; }
    var retryAsync = function (promise) {
        return promise
            .catch(function (err) {
            if (--times < 0 || !retryable(err))
                throw err;
            return retryAsync(fn());
        });
    };
    var retrySync = function (_err) {
        while (--times >= 0) {
            try {
                return fn();
            }
            catch (err) {
                if (!retryable(err))
                    throw err;
                _err = err;
            }
        }
        throw _err;
    };
    try {
        var ret = fn();
        if (ret &&
            typeof ret === "object" &&
            typeof ret.then === "function") {
            return retryAsync(ret);
        }
        return ret;
    }
    catch (err) {
        if (!retryable(err))
            throw err;
        return retrySync(err);
    }
}
exports.retry = retry;
function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
exports.defer = defer;
function reflect(promise) {
    var inspection = inspect(promise);
    function handleResolution(value) {
        return {
            isRejected: false,
            isResolved: true,
            value: value,
        };
    }
    function handleRejection(error) {
        return {
            error: error,
            isRejected: true,
            isResolved: false,
        };
    }
    return inspection.promise
        .then(handleResolution, handleRejection);
}
exports.reflect = reflect;
function inspect(promise) {
    var inspectable = {
        isPending: true,
        isRejected: false,
        isResolved: false,
        promise: void 0,
    };
    inspectable.promise = promise.then(function (value) {
        inspectable.isResolved = true;
        inspectable.isPending = false;
        return value;
    })
        .catch(function (err) {
        inspectable.isRejected = true;
        inspectable.isPending = false;
        return Promise.reject(err);
    });
    return inspectable;
}
exports.inspect = inspect;
function deferInspectable() {
    var deferred = defer();
    var ret = {
        isPending: true,
        isRejected: false,
        isResolved: false,
        promise: deferred.promise,
        resolve: function (t) {
            if (!ret.isPending)
                return;
            deferred.resolve(t);
            ret.isPending = false;
            ret.isRejected = false;
            ret.isResolved = true;
        },
        reject: function (err) {
            if (!ret.isPending)
                return;
            deferred.reject(err);
            ret.isPending = false;
            ret.isRejected = true;
            ret.isResolved = false;
        },
    };
    return ret;
}
exports.deferInspectable = deferInspectable;
function Try(cb) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, cb()];
        });
    });
}
exports.Try = Try;
// This logic is taken from Bluebird
function catchFilter(filters, err) {
    return (Array.isArray(filters) ? filters : [filters])
        .some(function (filter) {
        var e_3, _a;
        if (filter == null)
            return false;
        if (filter === Error ||
            filter.prototype instanceof Error) {
            if (err instanceof filter)
                return true;
        }
        else if (typeof filter === "function") {
            var filterFn = filter;
            // It is "ok" for this to throw. It'll be thrown back to the catch
            // handler, and the promise chain will contain this error.
            return filterFn(err);
        }
        else if (typeof filter === "object") {
            var obj = filter;
            try {
                for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (obj[key] !== err[key])
                        return false;
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return true;
        }
        return false;
    });
}
function specific(filters, handler) {
    return function (err) {
        if (!catchFilter(filters, err))
            throw err;
        return handler(err);
    };
}
exports.specific = specific;
function rethrow(fn) {
    var _this = this;
    return function (err) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fn(err)];
                case 1:
                    _a.sent();
                    throw err;
            }
        });
    }); };
}
exports.rethrow = rethrow;
function wrapFunction(wrap) {
    // tslint:disable-next-line
    return function (t, cb) {
        var _a, _b;
        var _this = this;
        if (arguments.length === 1) {
            if (wrap.length > 0)
                throw new EvalError("Invalid invocation, function requires 2 arguments");
            cb = t;
            t = void 0;
        }
        var anyCleanup = wrap(t);
        var callCleanup = function (cleanup) {
            if (typeof cleanup === "function")
                return cleanup();
            else if (cleanup != null)
                // Allow 'before' to just return null/undefined, but non-empty
                // value would've been silently ignored.
                throw new EvalError("Invalid return value in 'before' handler");
        };
        if (anyCleanup &&
            typeof anyCleanup.then === "function") {
            var doCleanup_1;
            return (_a = anyCleanup
                .then(function (cleanup) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    doCleanup_1 = function () { return callCleanup(cleanup); };
                    return [2 /*return*/, cb()];
                });
            }); }))
                .then.apply(_a, __spread(Finally(function () {
                if (doCleanup_1)
                    return doCleanup_1();
            })));
        }
        else {
            var cleanup_1 = anyCleanup;
            var cbRet_1;
            try {
                cbRet_1 = cb();
            }
            catch (err) {
                var cleanupRet = callCleanup(cleanup_1);
                if (cleanupRet &&
                    typeof cleanupRet.then === "function") {
                    return cleanupRet
                        .then(function () { throw err; });
                }
                else {
                    throw err;
                }
            }
            if (cbRet_1 && typeof cbRet_1.then === "function") {
                return (_b = cbRet_1)
                    .then.apply(_b, __spread(Finally(function () { return callCleanup(cleanup_1); })));
            }
            else {
                var cleanupRet = callCleanup(cleanup_1);
                if (cleanupRet &&
                    typeof cleanupRet.then === "function") {
                    return cleanupRet
                        .then(function () { return cbRet_1; });
                }
                else {
                    return cbRet_1;
                }
            }
        }
    };
}
exports.wrapFunction = wrapFunction;
function funnel(opts) {
    if (opts === void 0) { opts = {}; }
    var _a = (opts || {}), onEmpty = _a.onEmpty, _b = _a.concurrency, concurrency = _b === void 0 ? 1 : _b;
    var FunnelState;
    (function (FunnelState) {
        FunnelState[FunnelState["DEFAULT"] = 0] = "DEFAULT";
        FunnelState[FunnelState["SHOULD_RETRY"] = 1] = "SHOULD_RETRY";
        FunnelState[FunnelState["WAITING"] = 2] = "WAITING";
        FunnelState[FunnelState["COMPLETED"] = 3] = "COMPLETED";
    })(FunnelState || (FunnelState = {}));
    /**
     * All ongoing tasks (functions) regardless of state they are in.
     * If they return/throw or shortcut, they get cleared from this map.
     * The order is preserved for fifo fairness.
     */
    var tasks = new Map();
    var countWaiting = function () {
        return __spread(tasks.values()).filter(function (_a) {
            var state = _a.state;
            return state === FunnelState.WAITING;
        })
            .length;
    };
    var countWorking = function () {
        return __spread(tasks.values()).filter(function (_a) {
            var state = _a.state;
            return state === FunnelState.SHOULD_RETRY;
        })
            .length;
    };
    var freeSlots = function () {
        return Math.max(0, concurrency - countWorking());
    };
    var triggerWaiting = function () {
        var amountToResume = freeSlots();
        __spread(tasks.values()).filter(function (_a) {
            var state = _a.state;
            return state === FunnelState.WAITING;
        })
            .slice(0, amountToResume)
            .forEach(function (task) {
            task.resume();
        });
    };
    return function (fn) {
        var sentry = {};
        var store = {
            state: FunnelState.DEFAULT,
            counted: false,
            resume: undefined,
        };
        tasks.set(sentry, store);
        var shouldRetry = function () {
            if (store.state === FunnelState.COMPLETED)
                // shortcut before should/retry shortcuts through
                return false;
            var free = freeSlots();
            var shouldContinue = free > 0;
            if (store.state !== FunnelState.DEFAULT)
                throw new Error("Invalid use of 'shouldRetry'");
            store.state = FunnelState.SHOULD_RETRY;
            store.counted = true;
            return !shouldContinue;
        };
        var retry = function () {
            if (store.state !== FunnelState.SHOULD_RETRY)
                throw new Error("Invalid use of 'retry', " +
                    "must only be called after 'shouldRetry'");
            store.state = FunnelState.WAITING;
            var deferred = defer();
            var resume = function () {
                store.state = FunnelState.DEFAULT;
                store.resume = undefined;
                deferred.resolve(runner());
            };
            store.resume = resume;
            return deferred.promise;
        };
        var shortcut = function () {
            if (store.state === FunnelState.COMPLETED)
                return;
            store.state = FunnelState.COMPLETED;
            tasks.delete(sentry);
            if (countWaiting() === 0)
                onEmpty === null || onEmpty === void 0 ? void 0 : onEmpty();
            else
                triggerWaiting();
        };
        var runner = function () {
            var _a;
            return (_a = Try(function () { return fn(shouldRetry, retry, shortcut); }))
                .then.apply(_a, __spread(Finally(shortcut)));
        };
        return runner();
    };
}
exports.funnel = funnel;
var OrderedAsynchrony = /** @class */ (function () {
    function OrderedAsynchrony() {
        this.deferrals = [];
    }
    OrderedAsynchrony.prototype.wait = function (waitForIndex, resolveIndex, rejectIndex) {
        var _this = this;
        this.ensureDeferral(__spread(([].concat(waitForIndex)), (resolveIndex == null ? [] :
            [].concat(resolveIndex)), (rejectIndex == null ? [] :
            [].concat(rejectIndex))));
        return this.decorate(Promise.all([].concat(waitForIndex)
            .map(function (index) { return _this.deferrals[index].promise; }))
            .then(function () {
            return Promise.all([
                resolveIndex == null
                    ? void 0
                    : _this.resolve(resolveIndex),
                rejectIndex == null
                    ? void 0
                    : _this.reject(rejectIndex),
            ])
                .then(function () { });
        }));
    };
    OrderedAsynchrony.prototype.resolve = function (index) {
        var _this = this;
        this.ensureDeferral(index);
        return this.decorate(delay(0).then(function () {
            [].concat(index)
                .forEach(function (index) {
                _this.deferrals[index].resolve();
            });
        }));
    };
    OrderedAsynchrony.prototype.reject = function (index, error) {
        var _this = this;
        if (error === void 0) { error = new Error("OrderedAsynchrony rejection"); }
        this.ensureDeferral(index);
        return this.decorate(delay(0).then(function () {
            [].concat(index)
                .forEach(function (index) {
                _this.deferrals[index].reject(error);
            });
        }));
    };
    OrderedAsynchrony.prototype.ensureDeferral = function (index) {
        var indices = []
            .concat(index)
            .sort(function (a, b) { return b - a; });
        var highest = indices[0];
        for (var i = this.deferrals.length; i <= highest; ++i)
            this.deferrals.push(defer(void 0));
        return this;
    };
    OrderedAsynchrony.prototype.decorate = function (promise) {
        // tslint:disable-next-line:variable-name
        var This = {
            decorate: this.decorate.bind(this),
            deferrals: this.deferrals,
            ensureDeferral: this.ensureDeferral.bind(this),
            reject: this.reject.bind(this),
            resolve: this.resolve.bind(this),
            wait: this.wait.bind(this),
        };
        return Object.assign(promise, This);
    };
    return OrderedAsynchrony;
}());
exports.OrderedAsynchrony = OrderedAsynchrony;
function deferSet() {
    return new OrderedAsynchrony();
}
exports.deferSet = deferSet;
